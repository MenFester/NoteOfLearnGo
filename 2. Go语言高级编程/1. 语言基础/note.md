# 学习笔记

* Go语言的赋值和函数传参规则很简单：除闭包函数以引用的方式对外部变量访问之外，其他赋值和函数传参都是以传值的方式处理：
  * 数组：整体复制
  * 字符串：复制数据地址和对应长度
  * 切片：复制切片头信息，不复制底层

## 数组

* 数组定义方式：
  
```go
var a [3]int
var b = [...]int{1, 2, 3}
var c = [...]int{2:3, 1:2}    // {0, 2, 3}
var d = [...]int{1, 2, 4:5, 6}    // {1, 2, 0, 0, 5, 6}
```

* Go语言中数组是值语义。一个数组变量表示整个数组，并不是隐式地指向第一个元素的指针，而是一个完整的值。当一个数组变量被赋值或者传递的时候，实际上会复制整个数组。为了避免复制数组带来的开销可以传递一个指向数组的指针，但是数组指针并不是数组。因为数组长度是数组类型的组成部分，指向不同长度数组的指针类型也是完全不同的

```go
var a = [...]int{1, 2, 3}
var b = &a

fmt.Println(b[0], b[1])    // 通过数组指针访问数组元素的方式和通过数组类似
for i, v := range b {
    fmt.Println(i, v)
}
```

* 可以将数组看做一个特殊的结构体，结构体字段名对应数组的索引
* len()：计算数组长度
* cap()：计算数组容量，对于数组来说返回结果和len()一样
* for range方式迭代数组性能更好一些，可以保证不会出现数组越界的情形
* 数组不仅可以指定数值数组，还可以定义字符数组、结构体数组、函数数组、接口数组、通道数组等
* 长度为0的数组（空数组）在内存中并不占空间。空数组虽然很少直接使用，但是可以用于强调某种特有的类型的操作时避免分配额外的空间（例如用于通道的同步操作）

```go
c1 := make(chan [0]int)
go func() {
    fmt.Println("c1")
    c1 <- [0]int{}    // 不关心通道中传输数据的真实类型，通道的接收和发送只是用于消息的同步
}()
<- c1
```

* 一般更倾向于用无类型的匿名结构体代替空数组

```go
c2 := make(chan struct{})
go func() {
    fmt.Println("c2")
    c2 <- struct{}{}    // struct{}部分是类型， 第二个{}代表对应结构体的值
}()
<- c1
```

* 使用for range方式迭代，还可以忽略迭代的下标

```go
var times [5][0]int
for range times {    // 整个数组占用内存的大小是0，不用付出额外的内存代价， 通过for range实现times次快速迭代
    fmt.Prlintln("hello")
}
```

## 字符串

* 一个字符串是一个不可改变的字节序列，是一个只读的字节数组
* 每个字符串的长度虽然是固定的，但是字符串的长度并不是字符串类型的一部分
* 字符串面值常量UTF8编码，源代码中的文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列
* for range等语法不能支持非UTF8编码的字符串的遍历，这时将字符串（非UTF8编码）看做一个只读的二进制数组更准确
* 字符串的解构由两个信息组成：第一个是字符串指向底层字节数组；第二个是字符串的字节的长度。
* 字符串其实是一个结构体，因此字符串的赋值操作也就是reflect.StringHeader结构体的复制过程，并不会涉及底层字节数组的复制

```go
type StringHeader struct {
    Data uintptr
    Len int
}
```

* 字符串虽然不是切片，但是支持切片操作

```go
s := "hello, world"
hello := s[:5]
world := s[7:]

s1 := "hello, world"[:5]
s2 := "hello, world"[7:]

fmt.Println("len(s):", (*reflect.StringHeader)(unsafe.Pointer(&s)).Len)
fmt.Println("len(s1):", (*reflect.StringHeader)(unsafe.Pointer(&s1)).Len)
```

* 如果不想解码UTF8字符串，想直接遍历原始的字节码，可以将字符串强制转换为[]byte字节序列后再进行遍历（这里的转换一般不会产生运行时开销）。或者采用传统的下标方式遍历字符串的字节数组

```go
for i, c := range []byte("世界abc") {
    fmt.Println(i, c)
}

const s3 = "世界abc"
for i := 0; i < len(s3); i++ {
    fmt.Printf("%d %x\n", i, s3[i])
}
```

* Go语言还对字符串和[]rune类型的相互转换提供了特殊的支持

```go
fmt.Printf("%#v\n", []rune("世界"))
fmt.Printf("%#v\n", string([]rune{'世', '界'}))    // 注意这里是单引号
```