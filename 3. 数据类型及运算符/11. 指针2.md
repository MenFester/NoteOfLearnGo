* 拿到地址：
```go
x, y := 3, 5
fmt.Printf("%d, %p, %d, %p\n", x, &x, y, %y)
```

* 指针变量的创建，指针的宽度和操作系统有关
```go
var ptr1 *int = &x
prt2 := &y
fmt.Printf("%p, %T, %p, %d\n", ptr1, ptr1, ptr2, *ptr1)
```

* 使用new函数也能返回指针。make一般用户内置变量，new一般用于自己的。new直接在堆上开一片内存，然后将内存地址返回
```go
prt3 := new(int)
*ptr3 = 10
fmt.Printf("%p, %T, %d\n", ptr3, prt3, *ptr3)
```

* 函数参数的三种传递方式：
    * 值传递
    * 值类型的引用传递（指针传递）
    * 引用传递，传任何引用类型就是传的地址，无法做到传值。
* 与C、C++不同点
    * Java第一个摒弃了指针的
    * Go语言中，不同类型的指针不能相互转化。例如：*int32与*int64不能相互转化。
    * Go语言中，任何普通类型的指针，与uintptr之间不能相互转化。
    * 指针变量不能进行运算，不能++、--。