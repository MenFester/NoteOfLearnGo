
* 变量的作用域：
    * 局部变量：函数内部、if或for的块内
    * 全局变量：包内部
    * 函数的形参：函数内部
* 实现的原理：
    * Go是编译语言，不是解释脚本语言。脚本语言是解释一行、执行一样，是拿着变量名去找，找不到报错。编译语言编译后变量名就不见了。
    * 编译、链接、打包 => 函数/二进制码片段/可执行文件
        * 编译：源代码->代码片段（二进制）->链接->可执行文件
        * 任何一个可执行文件是分段的：代码段、data段、bss段、stack栈、heap堆
    * 运行阶段：启动一个进程，初始化不同的段 segement,data,bss,code,stack,heap
    * 函数的调用和返回：cs+ip，顺序执行，遇到systemcall、压栈（包括cs+ip）、修改cs+ip、运行函数、栈上分配局部变量...反向释放栈、恢复...
        * 函数的局部变量、函数的形参都是在函数调用后，临时在stack栈上分配，函数退出，编译器阻止继续访问。
        * 形参、局部变量，值类型，不用new关键字，分配在栈stack上。
        * 用new关键字的引用类型，指针分配在栈上，内存分配在heap堆上。
        * 初始化的全局变量在data段上，没有初始化的全局变量在bss段上。
* 闭包：函数引用了函数作用域以外的自由变量，通常我们把自由变量所在的环境称为引用环境。因为函数的存在，自由变量不得释放或删除。返回函数 + 引用环境 = 闭包。
* 闭包的实现原理：变量的逃逸——凡是闭包中的自由变量，本来应该分配在stack上，但是编译器经过分析后，分配到heap上，所以在函数退出后还是可以访问这个自由变量。` go build --gcflags=-m main.go `
* 每次独立调用会产生不同的闭包，返回不同闭包的自由变量不同，不是一个变量。
* 不用填语言处理闭包的情况：
    * Python，脚本语言，解释器，天然支持闭包，通过nonlocal声明
    * JavaScript，脚本语言，通过作用域链实现，产生闭包父函数的内存块无法释放
    * C++，C++11以前通过STL或者boost模拟，C++11后增加了原生的支持，实现原理与Go比较像
    * Java，JDK1.8以前使用Function接口和Lambda表达式实现闭包，闭包的数据是只读的，JDK1.8以后可以使用匿名类。