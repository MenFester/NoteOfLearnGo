# 学习笔记

* 面向对象：
    * 封装：抽象数据和对数据进行的操作封装在一起，数据被保存在内部，程序的其他部分只有通过被授权的操作——成员方法才能对数据进行操作。Go语言也有封装。
    * 继承：子类拥有父类的属性和方法，可以重新定义，也可以追加属性和方法。Go语言不支持继承。
    * 多态：所有声称支持父类（或者接口）的环境里，它的子类实例（接口实例）都可以正常的工作。
* Go语言不支持继承，以及继承多态，支持组合多态（基于接口的多态）
* Go语言中只有struct，没有class
* struct的定义
```go
type Point struct {
    X int    // 没有逗号
    Y int
}
```

* struct实例化：
    * 声明+赋值
```go
var p Point
p.X = 10
p.Y = 20
fmt.Println(p)
```
    * new创建一个指针+赋值
```go
p2 := new(Point)
p2.X = 30    // (*p).X写法可以，但是不建议
p2.Y = 40    // 语法糖
fmt.Println(p2)
```

    * 直接量
```go
p3 := Point{X:50, Y:55}
fmt.Println(p3)
```

* Go语言中没有构造函数。可以实现一个工厂函数。构造函数调new的时候直接调用，跟编译器有关。
* 需要注意：` 结构体是值类型 `。
```go
func createPoint(X, Y int) *Point {
    p := Point{X: X, Y: Y}
    // 此处返回局部地址变量
    return &p
}

p4 := createPoin(80, 90)
fmt.Println(p4)
```

* 变量到底是在栈上还是在堆上
    * C,C++：声明在栈上，new在堆上，堆上内存需要自己维护。
    * Java,.Net等：只要是引用类型都声明在堆上，所有堆上的对象都有gc来维护。
    * Go：声明的变量不一定在栈上，有些情况下会逃逸到堆上。凡是分配到堆上和逃逸到堆上的变量，都由gc来释放。变量的逃逸由编译器来做决定，程序员只能做逃逸分析：
        * 函数的返回值是通过变量逃逸实现的
        * 函数返回引用通过变量逃逸实现的
        * 闭包通过变量逃逸实现
* 函数的接收器，接收器可以是指针类型，也可以是非指针类型，调用方法一样。Go语言不需要this或self指针，名字自己随便写。
* 接收器是指针类型值，nil也可以调用。底层估计还是实现为指针类型作为函数参数...
```go
func (p Point) print() {
    fmt.Printf("X=%d, Y=%d\n", p.X, p.Y)
}

func (p *Point) print2() {
    fmt.Printf("print2: %p\n", p)
}
var p5 *Point = nil
p4.print2()
```

* 接收器使用指针类型还是非指针类型：
    * 如果需要修改内容，就必须使用指针接收器
    * 如果结构体的内存过大，应该尽量使用指针接收器
    * 一致性原则，避免把指针接收器和非指针接收器混合使用。
    * 其实非指针接收器，是Go语言特有的。对调用者透明，只有在定义的地方才看得出是否指针接收器